---
title: learncpp - 02 - 函数和文件
date: 2025-03-17 23:05:29
tags:
---

开始有意思了

## 2.5 局部作用域

- 翻译中的“超出作用域”(Out of scope)和“离开作用域”(Get out of scope)，如果看英文就非常明显了，主要是主语的区别：
  - 一个变量在一个作用域内，对该上下文以外的代码而言，这个变量就在别的代码的作用域之外，也就是**超出了其他代码的作用域**
  - 一个变量所在的作用域结束了，作用域都没了，里面的变量**自然就要离开其所在的作用域**
- 生命周期和作用域两个概念关系紧密，但最根本的区别是：**生命周期是运行时概念，而作用域是编译时概念。**他们之间的关系紧密在于，在目前这个学习阶段，很多时候变量**在生命周期中的创建与销毁**与**作用域的开始与结尾**是重合的。

## 2.7 前向声明和定义

- 声明/Declaration和定义/Definition非常相近：
  - 定义指的是对某个标识符的实现或实例化，是为了**满足链接器的需要**。
  - 声明纯粹是告知某个标识符的存在，是为了**满足编译器的需要**。
  - 因此我们在一个文件里使用前向声明，来解决编译器读文件顺序先后的问题。

### 单一定义规则/One Definition Rule

1. 在一个文件中，一个函数、变量、类型或模板只能够被定义一次；
2. 在一个程序中，一个变量或普通函数只能够有一个定义；
3. 类型、模板、内联函数和内联变量可以有一样的定义，但必须位于不同的文件中。

如果违反了 ODR 的第一条规则，会导致编译器报告重复定义的错误。如果违反了 ODR 的第二条规则，则很可能导致链接器报告重复定义错误。违反 ODR 第三条规则则会导致未定义行为。

## 2.10 预处理器简介

- `#include`: 预处理器会将`#include`替换成文件实际内容
- `#define` 指令可以被用来定义宏(macro)，规定了一个输入文本应该如何被替换成输出文本，比如`#define MY_NAME "Alex"`或者`#define MY_NAME`。
- 条件编译的指令比较常用的4个：
  - `#ifdef`、`#ifndef`、`#endif`：`#ifdef`指令会让预处理器检查某个标识符是否被`#define`过，如果是的话，`#ifdef`和`#endif`之间的代码将会被编译，否则这些代码会被忽略。`#ifndef`则是相反的。
  - `#if 0`可以将它包裹范围内的代码排除在编译之外。

## 2.11 头文件

随着程序越来越大（以及越来越多的文件被使用），我们希望将所有的前向声明都放在一个文件里，然后在需要使用的时候将其导入。

- **C++ 中的最佳实践之一就是源文件应该包含其对应的头文件（如果存在的话）。**
- 有的头文件是用的尖尖的括号，但有的是双引号。前者是告知预处理器这个头文件并不是我们编写的，编译器**只会在include directories指定的目录**里搜索，而后者则优先在当前目录中查找。
- **在使用标准库头文件的时候，使用没有.h版本的头文件。**对于用户自己编写的头文件，仍然需要使用.h后缀。
- 如果想include其他目录中的头文件，**建议在IDE/构建工具的Include Directories之类的配置**中进行配置。
- 对于编译所需的头文件，每一个都应该被**明确地**使用 #include 包含进来。**不要依赖被间接包含的头文件。**
- 为了最大程度减少头文件没有正确包含引起的编译器报错，请按照如下顺序包含头文件：

  1. 先包含源文件对应的头文件；
  2. 再包含项目所需的其他头文件；
  3. 再包含第三方库的头文件；
  4. 再包含标准库头文件，每一组头文件都应该按照字母表顺序排序。

## 2.12 头文件防卫式声明

如果头文件中存在定义，那么它很有可能会被多次导入、重复地包含到代码中，违背ODR导致编译报错。

我们使用header guard技术避免上述问题，其形式如下：

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE
 
// your declarations (and certain types of definitions) here
 
#endif
```

**所有头文件都应该使用头文件防卫式声明。** 很多开发者还建议使用更复杂/独特的方式来构建相关的宏。

然而，**头文件防范的目标是防止头文件被多次包含，而不是被多个文件包含。** 所以最简单的方法是，**只将声明而非定义放在头文件中。**

## 编程忠言

- **开始时一切从简**：很多新手程序员对其要实现的程序和功能具有宏伟的蓝图：“我想要设计一款具有图形界面、配乐和随机地牢的角色扮演游戏。不仅如此，游戏地图还包括城镇，你可以在城镇里售卖你收集到的战利品”。如果你从一开始就要完成一个非常复杂的任务，你可能会在进度不佳时感到不知所措或心灰意冷。所以，你其实应该将你开始时的目标设的尽可能简单，即一些你肯定能够完成的目标。例如，“我想要在屏幕上显示一个2D的区域”。

- **逐渐添加新的功能**：当上述简单的程序可以正常工作后，你就可以考虑为其增加新的功能了。例如，当上述2D区域可以被正常显示在屏幕上后，你可以添加一个能够移动的角色。当角色可以移动后，添加一些墙体限制角色的移动路径。墙体完成后，可以利用墙体来构建一个城镇地图。城镇完成后，添加一个商人NPC。通过这种循序渐进的方式为你的程序添加新功能，程序最终会变得越来越复杂，同时也不会让你在这个过程中感到不知所措。

- **一次只做一件事**：不要期望一次性写完全部的代码，也不要把你的注意力分散在多个任务上。一次只做一件事。一个正常工作的功能+五个尚未实现的功能，好过六个不能正常工作的功能。注意力被分散的时候，你会更容易犯错，也更容易忘记重要的细节。

- **一边实现、一边测试**：新的程序员常常会一次性写完全部的程序，然后才对其进行编译，然后就“收获”了非常多的报错信息。写完的代码不能编译，不仅吓人，而且还难以查找其产生错误的原因。正确的做法是编写一些代码，然后就对其进行编译和测试。如果不能正常工作，那么修复起来也非常简单。当你确定这些代码可以正常工作了，再重复上述操作，开始编写接下来的代码。这么做或许会“拖累”你的进度，但是实际上当你完成后 ，代码应该是能够正确工作的，这好过你写完代码后再花费两倍多的时间去定位问题。

- **不要过早地优化代码**：第一版功能（或程序）很少是完美的。而且，程序本身也会随着时间不断被更新，毕竟你还要为其添加功能，或者重新组织代码。如果你在早期就花费很多时间去打磨这些代码（添加很多文档、确保满足最佳实践、优化等），那么有可能会因为必须修改代码而使得这些努力都付之东流。正确的做法是，让你的程序功能保持最简可用，然后继续其他的工作。当你对程序感到满意时，再对其进行一系列的优化。不过，不要期望其达到完美的状态，大型程序很少是完美的，它总是有这样或那样的问题需要我们优化。做到足够好就可以了。

大多数新手程序员并不能很好的遵循上述忠言（因为看上去很麻烦，也不如写代码有趣）。但是，对于具有一定规模的代码来说，完整遵循上述建议绝对可以帮助你节约很多时间（从长期来看）。简单地进行一些设计规划，就可以为后期节约大量的调试时间。

好消息是，一旦你习惯了这么做以后，它便会慢慢地成为你的习惯。最终，你将能够不在进行任何预先设计的情况下，完成整个函数的编写。
