---
title: learncpp - 02 - 函数和文件
date: 2025-03-17 23:05:29
tags:
---

开始有意思了

## 2.5 局部作用域

- 翻译中的“超出作用域”(Out of scope)和“离开作用域”(Get out of scope)，如果看英文就非常明显了，主要是主语的区别：
  - 一个变量在一个作用域内，对该上下文以外的代码而言，这个变量就在别的代码的作用域之外，也就是**超出了其他代码的作用域**
  - 一个变量所在的作用域结束了，作用域都没了，里面的变量**自然就要离开其所在的作用域**
- 生命周期和作用域两个概念关系紧密，但最根本的区别是：**生命周期是运行时概念，而作用域是编译时概念。**他们之间的关系紧密在于，在目前这个学习阶段，很多时候变量**在生命周期中的创建与销毁**与**作用域的开始与结尾**是重合的。

## 2.7 前向声明和定义

- 声明/Declaration和定义/Definition非常相近：
  - 定义指的是对某个标识符的实现或实例化，是为了**满足链接器的需要**。
  - 声明纯粹是告知某个标识符的存在，是为了**满足编译器的需要**。
  - 因此我们在一个文件里使用前向声明，来解决编译器读文件顺序先后的问题。

### 单一定义规则/One Definition Rule

1. 在一个文件中，一个函数、变量、类型或模板只能够被定义一次；
2. 在一个程序中，一个变量或普通函数只能够有一个定义；
3. 类型、模板、内联函数和内联变量可以有一样的定义，但必须位于不同的文件中。

如果违反了 ODR 的第一条规则，会导致编译器报告重复定义的错误。如果违反了 ODR 的第二条规则，则很可能导致链接器报告重复定义错误。违反 ODR 第三条规则则会导致未定义行为。

## 2.10 预处理器简介

- `#include`: 预处理器会将`#include`替换成文件实际内容
- `#define` 指令可以被用来定义宏(macro)，规定了一个输入文本应该如何被替换成输出文本，比如`#define MY_NAME "Alex"`或者`#define MY_NAME`。
- 条件编译的指令比较常用的4个：
  - `#ifdef`、`#ifndef`、`#endif`：`#ifdef`指令会让预处理器检查某个标识符是否被`#define`过，如果是的话，`#ifdef`和`#endif`之间的代码将会被编译，否则这些代码会被忽略。`#ifndef`则是相反的。
  - `#if 0`可以将它包裹范围内的代码排除在编译之外。

## 2.11 头文件

随着程序越来越大（以及越来越多的文件被使用），我们希望将所有的前向声明都放在一个文件里，然后在需要使用的时候将其导入。

- **C++ 中的最佳实践之一就是源文件应该包含其对应的头文件（如果存在的话）。**
- 有的头文件是用的尖尖的括号，但有的是双引号。前者是告知预处理器这个头文件并不是我们编写的，编译器**只会在include directories指定的目录**里搜索，而后者则优先在当前目录中查找。
- **在使用标准库头文件的时候，使用没有.h版本的头文件。**对于用户自己编写的头文件，仍然需要使用.h后缀。
- 如果想include其他目录中的头文件，**建议在IDE/构建工具的Include Directories之类的配置**中进行配置。
- 对于编译所需的头文件，每一个都应该被**明确地**使用 #include 包含进来。**不要依赖被间接包含的头文件。**
- 为了最大程度减少头文件没有正确包含引起的编译器报错，请按照如下顺序包含头文件：

  1. 先包含源文件对应的头文件；
  2. 再包含项目所需的其他头文件；
  3. 再包含第三方库的头文件；
  4. 再包含标准库头文件，每一组头文件都应该按照字母表顺序排序。

## 2.12 头文件防卫式声明

如果头文件中存在定义，那么它很有可能会被多次导入、重复地包含到代码中，违背ODR导致编译报错。

我们使用header guard技术避免上述问题，其形式如下：

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE
 
// your declarations (and certain types of definitions) here
 
#endif
```

**所有头文件都应该使用头文件防卫式声明。** 很多开发者还建议使用更复杂/独特的方式来构建相关的宏。

然而，**头文件防范的目标是防止头文件被多次包含，而不是被多个文件包含。** 所以最简单的方法是，**只将声明而非定义放在头文件中。**
