---
title: learncpp - 06 - 作用域、生命周期和链接
date: 2025-03-21 00:09:18
tags:
---

渐入佳境

<!-- more -->

## 6.2 - 用户定义命名空间和作用域解析运算符

此前在2.9里介绍了命名冲突和命名空间：

- c++需要确保所有标识符是没有歧义的，否则编译器或者链接器无法区分，就会报告命名冲突的错误
- 因此我们可以用命名空间/namespace来区分，为标识符提供一个作用域范围，不会与其他作用域中同名的标识符产生冲突

C++ 允许我们通过namespace关键字创建你自己的命名空间。用户为了自己的声明创建的命名空间，称为**用户自定义命名空间**。

而为了访问一个命名空间里的标识符，我们会使用**作用域解析运算符**(`::`)，其左边的操作数是编译器应该查找的命名空间。

不带前缀的作用域解析运算符（`::print()`）代表着全局命名空间，这在自定义命名空间的作用域内避免标识符遮蔽可以派上用场。

命名空间的定义可以放在多个文件或相同文件的不同位置，编译器会将所有声明认为是对应命名空间的一部分。

命名空间可以嵌套，为此在访问时要使用连续的多个作用域解析运算符。我们也可以为命名空间创建别名，以避免很长的嵌套。

```cpp
#include <iostream>
 
namespace foo::goo
{
    int add(int x, int y)
    {
        return x + y;
    }
}
 
int main()
{
    namespace active = foo::goo; // active now refers to foo::goo
 
    std::cout << active::add(1, 2) << '\n'; // This is really foo::goo::add()
 
    return 0;
} // The active alias ends here
```

在编写库函数或者提供给别人使用的代码时，**始终将函数定义在自定义的命名空间内。**

## 6.3 - 局部变量

局部变量有以下特性：

- 局部变量具有**块作用域**，它们的**作用域被限定在定义它们的代码块中**。
  - 作用域中的所有变量必须具备不同的变量名。
- 局部变量的**存储持续时间是自动的，会在定义时被创建、并且在语句块结束时销毁**。
- 局部变量**没有链接性**。也就是说，**每个声明都指代的是一个唯一的对象**。
  - 连接性与作用域的区别是，作用域定义了一个单独的声明在哪里可以被访问，而链接性定义了多个声明是否指代同一个对象。

## 6.4 - 全局变量

我们和局部变量用类似的方式去考量全局变量的特性的话：

- 全局变量**具有文件作用域，其作用域限定在其所在的文件内**。
- 全局变量的**存储持续时间是静态的，在程序开始时被创建、并且在程序结束时被销毁**。
  - 我们将具有静态存储时间的变量称为**静态变量**。
- 全局变量的链接性将在下面讨论。**非常量的外部变量默认为外部链接**。

**不要定义非const的全局变量。**

## 6.6&7 - 内部链接、外部链接和变量前向声明

标识符的链接属性可以是以下三种：

- 内部链接/internal linkage
- 外部链接/external linkage
- 无链接性

### 内部链接

具有内部链接属性的标识符，**在一个文件内可见可用，但是在其他文件中不可访问**，这意味着其不会被暴露给链接器（这也是链接性的语义所在）。这意味着，**如果两个文件中具有同名的标识符**，且它们**具有内部链接**，**这些标识符会被看做是互相独立的**。

我们将具有内部链接的全部变量称为**内部变量**。通过`static`关键字，我们可以将一个非常量的全局变量声明为内部变量。

```cpp
static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword
 
const int g_y { 1 }; // const globals have internal linkage by default
constexpr int g_z { 2 }; // constexpr globals have internal linkage by default
 
int main()
{
    return 0;
}
```

> Const 和 constexpr 类型的全局变量默认具有内部链接属性。

定义在不同文件中的内部对象会被看作独立的实体，因此这并不违反ODR。

因为链接是标识符的属性、而非变量的属性，函数的标识符同样具有链接属性，其默认是**外部链接**的，但可以用`static`修改为内部链接。

### 外部链接

具有外部链接属性的标识符**可以在其他文件中被使用**（通过**前向声明**）。因为函数默认具有外部链接属性，所以默认情况下可以在一个文件中调用另一个文件中的函数，但必须要在使用该函数的文件中进行前向声明。

具有外部链接属性的全局变量有时也被称为**外部变量**。使用`extern`关键字可以将全局变量定义为外部变量。

那么问题来了：对函数的前向声明可以通过是否有函数体来判断，但变量不能这么玩。所以，想在一个文件里使用另一个文件的一个外部变量，也需要用`extern`关键字：

```cpp
#include <iostream>
 
extern int g_x; // 这个 extern 是变量 g_x的前向声明，g_x被定义在其他文件
extern const int g_y; // 这个 extern 是 const 变量 g_y 的前向声明，它也被定义在其他文件
 
int main()
{
    std::cout << g_x; // prints 2
 
    return 0;
}
```

换句话说：

- 有些语境下，`extern` 表示 “为变量创建外部链接”（在定义时赋值）
- 而在另外的语境下，`extern` 表示 “这是一个定义在其他地方的外部变量的前向声明”（仅做声明、不赋值）

因此，**如果你希望定义一个未初始化的非const全局变量，不要使用 `extern` 关键字，否则 C++ 会认为你是在前向声明某个变量。**

## 6.8 - 为什么非 const 全局变量是魔鬼

- 非 const 类型的全局变量可以被所有函数修改，因此会让程序变得难以预料。
- 静态变量初始化有两个阶段
  - 第一阶段称为**静态初始化** 。在静态初始化阶段，constexpr 类型的全局变量（包括字面量）都会被初始化成具体的值。此外，没有显式初始化的全局变量也会被初始化为0。
  - 第二阶段称为**动态初始化**。这个阶段要复杂的多，但是它的精髓在于**具有非 constexpr 初始化值的全局变量会被初始化。** 这意味着不同文件中全局变量的初始化顺序是不确定的。
- 全局变量的动态初始化会造成很大问题，尽量避免动态初始化。

一般说来，使用全局变量至少要满足下面两个条件：**该变量在程序中的功能是唯一的，而且它会在程序的各个地方被使用。**

如果一定要用的话：

- 请为不在命名空间中的全局变量添加 “g” 或者 “g_” 前缀，或者干脆将它们放到一个命名空间中以**避免命名冲突**。
- **不要允许全局变量的直接访问**，最好是将它们“封装”起来。确保变量只能在定义它们的文件内部被访问，例如为变量添加`static`或`const`修饰符，然后提供一个外部的全局“访问函数”用于该变量的访问。
- 当函数必须使用全局变量的时候，**不要直接在函数体中使用全局变量。应该将全局变量作为参数传递给函数**，这样的话，不管什么时候你需要使用不同的值时，你只需要修改函数的入参就可以，这么做有助于保持函数的模块化。